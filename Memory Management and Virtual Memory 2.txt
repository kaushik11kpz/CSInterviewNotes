-Overlays- It is a process of memory Management where management is done by Programmer, in which a Process is segmented and various
segments were put in Main memory and taken out by the programmers according to their need
-Since, it involves Programmers, it is not a good solution, OS should be doing it by itself
 
---Paging in Memory Management
-Most famous memory management technique
-Main Memory is divided into slots of equal sizes known as frames
-Process is divided into slots of equal sizes known as Pages
-Sizes of frames and Pages must be equal every Page has to go in Frame
-When Process is loaded into memory, its individual Pages are loaded at different frames
-These Pages can be loaded at Contiguous and Non Contiguous location
-Fragementation problem is solved
-Runtime Address Binding occurs as relocatable address cannot be converted to physical address as Pages of Processes(Process are divided across multiple frames)
are at Non Contiguous location in main memory. Different pages of Processes can be moved out of main memory for I/O while many Pages of same Processes may exist in main memory,
This logical address is required which comes from Runtime Binding
-CPU is not aware of Non contiguous locations, thus CPU considers processes at Contiguous locations and generates logical address according to it
-Conversion of these logical addresses to physical address is quite an interesting process
-This leads to the concept of Page Table

--Page Table
-It stores the mapping of logical address Pages to main memory frames
-It has every entry for every Page to Frame mapping
-It has to be present in Main Memory for quick accessing
-When a Process is loaded into memory, a Page Table is created for it
-Computer hardware supports Page Table by suppoting Registers such as 
  -Page Table Base Register
     -When Context Switching(Process is loaded into memory) happens, Page Table Base Register stores the address of the Page Table
  -Page Table Length Register
     -It is for security purpose
-These two registers gives access to the Page Table
-If a Page is needed, the corresponding Frame address is Present in the Page Table
-As Page table is accessed by the Page Table Base Register, it gives the frame number in which a particular Page is stored in Main Memory
-Page size cannot be very small as this will be very long size Page Table
-A trade off happens between size of Page Table and Fragementation
-If Page Table is very large or very small, it leads to Fragementation
-The geneal chosen size is 4 kb, it means Page has many bytes which can be addressed indiviually
-So, logical address contains Page Number and Offset within the Page (With Page 2(P=2), I need to access 3rd item (d=3))
-So, Page number generated by logical address is passed to Page Table and this Page Table tells you the frame number in Physical Memory
-This is how logical address is converted to Physical address

-Sometimes all these Pages are not present in Main Memory. This is called Page Fault
-Page Table has a bit which stores whether a particular table is Present in Main Memory. It tells by showing status such as Valid for present and Invalid for absent
-When in need the Invalid(absent) Page is brought into main memory from Hardisk
-Page table also contains field Modified Bit/Dirty Bit
-It tells whether a Page was modified in RAM
-For writing back to Hardisk after Processes swapped of RAM, Modified Bit/Dirty Bit is used to do this optimization
-If modification is done, it needed to be write on Hardisk otherwise no need to write on hardisk
-Cacheable field in Page Table tells whether this Page is cacheable or not
-Fields in Page Table are System Specific


---Virtual Memory
-It is the extenstion of Paging in Memory Management
-It states that Whole Process should not be there in the memory, but only the required part of the Process has to be in the memory and the Process need not to know about it
-It only talks about logical addresses
-Giving a Process illusion that you have full memory available and keeping only part of it in RAM(main memory) is called Virtual Memory
-Closely related to Paging
-Remember valid Invalid bit in Page table entry
-Page fault 
  -It happens here which is a costly operation as:
  -Mode switch happens(Control goes from Process to OS)
  -OS runs code to bring this Page from Hardisk to RAM ,it is slow as hardisk is vey slow compared to CPU
  -Average waiting time increases
-Even if the hit percentage of RAM is 99% and RAM access time is 10 ns, 1% of Page Fault, increases RAM access time to 59um (micro)
-In ideal situation Page Fault is avoided
-Many ways to Implement Virtual Memory
1.Pure Demand Paging
  -Whenever some Page is required, then only load that Page to from Hardisk to RAM
  -Chances of Page Fault is higher
  -But, it also gives advantages
    -Degree of multi-programming goes high as many process are already present so context switching time is low
    -A tradeoff between degree of multi-programming and Page Fault

---TLB, Demand Paging, Thrashing, Page Replacement Algorithms
-These are thing related with Virtual Memory

--TLB
-Translational Lookaside Buffer
-It is an associative cache present in CPU
-The purpose of the TLB is to cache the Page Table for optimization in speed
-The Lookup occurs to convert logical address to physical address by using Page Table to locate the frame number
-This lookup is quite frequent, so this lookup is optimised by TLB
-Most of the time same page number is looked up
-TLB has very high hit rate
-The cache(TLB) is present in Processor

--Thrashing
-When we implement Pure Demand Paging, degree of multi-programming increases, but number of Page Fault also increases
-The leads to ineffective utilisation of CPU speed(utilization)
-CPU utilization vs Degree of Multi-programming graph shows inverse parabola, which is known as Thrashing
-In Thrashing many Page Fault occurs and CPU utilization goes down

--Page Replacement Algorithms
-When Page Fault occurs and the required Page is brought from hardisk to RAM, but RAM does not have space to accomodate incoming Page, to tackle it one of the existing Page in RAM
is replaced with incoming Page. This replacement happens through various Page Replacement Algorithms
-Page Replacement is local and global
-When we replace the same Process page to accomodate incoming Page of that Process. This is called local Page Replacement. It is also good approach
-When we replace the different Process page to accomodate incoming Page of another Process. This is called global Page Replacement. It gives overall better system performace, with minor
individual process problem
-These algorithms are:
1.First in First Out(Suffer's from belady anamoly)
-
2.Optimal
3.Least Recently used

---Segmentation in Memory Manageent
-It is an alternate of Paging
-Segmentation is an alternate to implement both the ideas
-The problem with Paging is
-If a long function is divided into two differnet page, it will cause Page fault, Thus
-The idea of segmentation is to bring the related item together into the Main Memory
1.Allowing Non continuous allocation of Process in Main Memory
2.Implementing Virtual Memory
-The idea of segmentation is to brought the related item together into the Main Memory
-These related items might be of different sizes not of the same sizes as Pages
-With, segmentation we divide our process according to User's view
-User's view is briging related item together
-The logical address are converted to physical address using Segment Table

-Segment Table contains fields such as
1. Base- Segment base of memory
2. Limit - Maximum logical address limit
2. Absent/Present

-Advanatges of Segmentation
1. Process can be loaded into Non-contiguous memory locations
2. Implement Virtual memory
-To implement Virtual memory we have to add absent/prsent field into segment table

-dividing the process into segments varies from OS to OS, system to system
-In xht6 architecture code segment, data segment, stack segment 

-CPU generates logical address and this logical address contains
1. Segment Number(s)
-With it, we get the base address of the segment number from segment table
-And limit of the segment number from segment table
2. Offset(d)
-First, we check if offset provided in the logical address by CPU is within the limits of the segment table
-if not, error or Segmentation fault occurs
-if offset is with limit then, => Offset(d) + Base address(base) = Physical address in main memory(RAM)
- This is how we access particular item with the given logical address using segmentation

Segmenatation
1.Pure segmentation
2.Segmentation with Paging
-It is implemetedin xhtc arechitecture

-Advanatges over Paging
1. No Internal Fragmetation
2. User view
   -No Page Fault or Memory Fault
3. Segment table is smaller then Page Table
   -Protection and Sharing is easy

-Disadvnatage - external Fragementation


---Segmentation with Paging
-Take advantages of both, Paging and Segmentation
-Here, a Process is divided into segments and each segments are furthur divided into Pages
-The Page size is equal to the Main Memory Frame size
-Mapping of Pages to frame is done, which is interesting
-Invidual segment have their own Page table
-Process have a segment table
-Logical address generated by CPU contains fields such as
1. Segment Number(s)
2. Page Number(p)
3. Offset(d)

-Advantages of Paging is efficient memory utilization
-Advantges of Segmentation is
 -User view
 -Protection
--Implementation of Segmentation with Paging
-How to know where to go for segment Table
-When context swictching a Register Segment Table Base Register is set in this Context switching
-This Register gives the base address of Segment Table
-Using this Segment table, go to page table
-Using Page Table go to Frame number
-Once, you find frame number add offset to it, to get actual physical address
-Segment Table has base address of corresponding Page table entry
-PageTable has base address of corresponding frame number
-If Page fault happens this frame is loaded
-Page table and Segment table both has limits to check number of logical addresses

-Disadvantage
-Segmentation with Paging causes two lookups
-We store Page Table mapping and Segment Table mapping in TLB, so these lookups can be performed faster


